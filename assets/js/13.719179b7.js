(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{598:function(_,t,v){_.exports=v.p+"assets/img/tcp_connect.666d7d20.jpg"},599:function(_,t,v){_.exports=v.p+"assets/img/tcp_same_connect.8de795e0.jpg"},656:function(_,t,v){"use strict";v.r(t);var a=v(11),s=Object(a.a)({},(function(){var _=this,t=_.$createElement,a=_._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[a("h2",{attrs:{id:"三次握手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[_._v("#")]),_._v(" 三次握手")]),_._v(" "),a("p",[_._v("TCP 的三次握手，也是需要确认双方的两样能力: "),a("code",[_._v("发送的能力和接收的能力")]),_._v("。于是便会有下面的三次握手的过程:")]),_._v(" "),a("p",[a("img",{attrs:{src:v(598),alt:"三次握手"}})]),_._v(" "),a("p",[_._v("开始双方都处于 CLOSED 状态。然后服务端开始监听某个端口，进入了 LISTEN 状态。")]),_._v(" "),a("ol",[a("li",[_._v("首先客户端主动发起连接，发送 SYN , 自己变成了 SYN-SENT 状态。")]),_._v(" "),a("li",[_._v("然后服务端接收到，返回 SYN 和 ACK (对应客户端发来的 SYN)，自己变成了 SYN-REVD。")]),_._v(" "),a("li",[_._v("最后客户端再发送 ACK 给服务端，自己变成了 ESTABLISHED 状态；服务端收到 ACK 之后，也变成了 ESTABLISHED 状态。")])]),_._v(" "),a("p",[_._v("从图中可以看出，SYN 是需要消耗一个序列号的，下次发送对应的 ACK 序列号要加 1，为什么呢？只需要记住一个规则:")]),_._v(" "),a("blockquote",[a("p",[_._v("凡是需要对端确认的，一定消耗 TCP 报文的序列号。")])]),_._v(" "),a("p",[_._v("SYN 需要对端的确认， 而 ACK 并不需要，因此 SYN 消耗一个序列号而 ACK 不需要。")]),_._v(" "),a("h3",{attrs:{id:"为什么不是两次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是两次"}},[_._v("#")]),_._v(" 为什么不是两次？")]),_._v(" "),a("p",[_._v("根本原因: "),a("strong",[_._v("无法确认客户端的接收能力")]),_._v("。")]),_._v(" "),a("p",[_._v("如果是两次，你现在发了 SYN 报文想握手，但是这个包滞留在了当前的网络中迟迟没有到达，TCP 以为这是丢了包，于是重传，两次握手建立好了连接。")]),_._v(" "),a("p",[_._v("看似没有问题，但是连接关闭后，如果这个滞留在网路中的包到达了服务端呢？这时候由于是两次握手，服务端只要接收到然后发送相应的数据包，就默认建立连接，但是现在客户端已经断开了, 这就带来了连接资源的浪费。")]),_._v(" "),a("h3",{attrs:{id:"为什么不是四次"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么不是四次"}},[_._v("#")]),_._v(" 为什么不是四次？")]),_._v(" "),a("p",[_._v("三次握手的目的是确认双方"),a("code",[_._v("发送")]),_._v("和"),a("code",[_._v("接收")]),_._v("的能力，那四次握手可以嘛？")]),_._v(" "),a("p",[_._v("当然可以，100 次都可以。但为了解决问题，三次就足够了，再多用处就不大了。")]),_._v(" "),a("h3",{attrs:{id:"三次握手过程中可以携带数据么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三次握手过程中可以携带数据么"}},[_._v("#")]),_._v(" 三次握手过程中可以携带数据么？")]),_._v(" "),a("p",[_._v("第三次握手的时候，可以携带。前两次握手不能携带数据。")]),_._v(" "),a("p",[_._v("如果前两次握手能够携带数据，那么一旦有人想攻击服务器，那么他只需要在第一次握手中的 SYN 报文中放大量数据，那么服务器势必会消耗更多的时间和内存空间去处理这些数据，增大了服务器被攻击的风险。")]),_._v(" "),a("p",[_._v("第三次握手的时候，客户端已经处于 ESTABLISHED 状态，并且已经能够确认服务器的接收、发送能力正常，这个时候相对安全了，可以携带数据。")]),_._v(" "),a("h3",{attrs:{id:"同时打开会怎样"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#同时打开会怎样"}},[_._v("#")]),_._v(" 同时打开会怎样？")]),_._v(" "),a("p",[_._v("如果双方同时发 SYN 报文，状态变化会是怎样的呢？可能发生的状态变迁如下图:")]),_._v(" "),a("p",[a("img",{attrs:{src:v(599),alt:"同时打开"}})]),_._v(" "),a("p",[_._v("在发送方给接收方发 SYN 报文的同时，接收方也给发送方发 SYN 报文，两个人刚上了!")]),_._v(" "),a("ul",[a("li",[_._v("发完 SYN，两者的状态都变为 SYN-SENT。")]),_._v(" "),a("li",[_._v("在各自收到对方的 SYN 后，两者状态都变为 SYN-REVD。")]),_._v(" "),a("li",[_._v("接着会回复对应的 ACK + SYN，这个报文在对方接收之后，两者状态一起变为 ESTABLISHED。")])]),_._v(" "),a("p",[_._v("这就是同时打开情况下的状态变迁。")]),_._v(" "),a("h2",{attrs:{id:"四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手"}},[_._v("#")]),_._v(" 四次挥手")]),_._v(" "),a("p",[_._v("客户端 -- FIN --\x3e 服务端， FIN—WAIT\n服务端 -- ACK --\x3e 客户端， CLOSE-WAIT\n服务端 -- ACK,FIN --\x3e 客户端， LAST-ACK\n客户端 -- ACK --\x3e 服务端，CLOSED")])])}),[],!1,null,null,null);t.default=s.exports}}]);