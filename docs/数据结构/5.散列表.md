---
title: '散列表'
date: 2020-03-26
permalink: 'data-structure/hash_table'
tag:
  - data-structure
categories:
  - data-structure
---

## 定义

如果要在字典数据结构中获得一个值（使用 get 方法），需要遍历整个数据结构来得到它。

散列算法的作用是尽可能快地在数据结构中找到一个值，如果使用散列函数，就知道值的具体位置，因此能够快速检索到该值，散列函数的作用是给定一个键值，然后返回值在表中的地址

## 实现

```js
class HashTable {
  constructor() {
    this.table = [];
  }

  put(key, value) {
    const position = HashTable.loseloseHashCode(key);
    this.table[position] = value;
  }

  get(key) {
    return this.table[HashTable.loseloseHashKey(key)];
  }

  remove(key) {
    this.table[HashTable.loseloseHashCode(key)] = undefined;
  }

  static loseloseHashKey(key) {
    let hash = 0;
    for (let codePoint of key) {
      hash += codePoint.charCodeAt();
    }
    return hash % 37;
  }
}
```

可以看出，经过 loseloseHashKey 方法处理后的结果可能会存在冲突，如下:

```js
const hash = new HashTable();
hash.put('Gandalf', 'gandalf@email.com');
hash.put('John', 'johnsnow®email.com');
hash.put('Tyrion', 'tyrion@email.com'); // 16
hash.put('Aaron', 'aaronOemail.com'); // 16
hash.put('Donnie', 'donnie@email.com'); // 13
hash.put('Ana', 'ana©email.com'); // 13
hash.put('Jonathan', 'jonathan@email.com'); // 5
hash.put('Jamie', 'jamie@email.com'); // 5
hash.put('Sue', 'sueOemail.com'); // 5
hash.put('Mindy', 'mindy@email.com'); // 32
hash.put('Paul', 'paul©email.com'); // 32
hash.put('Nathan', 'nathan@email.com');
```

相同的散列值可能会导致最终的数据对象中，只有最后一次被添加/修改的数据会覆盖原本数据，因此就需要解决这个冲突。处理冲突有几种方法：**分离链接**、**线性探查**和**双散列法**。

## 分离连接
